<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>Penalty Shootout (10 Kicks) — Stadium Upgrade</title>
  <style>
    :root{
      --bg:#071322;
      --panel: rgba(10,14,22,.62);
      --stroke: rgba(255,255,255,.12);
      --text:#e9f0ff;
      --muted:#a9b6cc;
      --accent:#66e3ff;
      --good:#35f3a1;
      --bad:#ff5c7a;
    }
    *{box-sizing:border-box}
    html,body{height:100%; margin:0; font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial;}
    body{
      background: radial-gradient(1200px 700px at 50% 10%, #1a3a5a 0%, var(--bg) 45%, #04101c 100%);
      color:var(--text);
      display:flex; justify-content:center; align-items:center;
      padding:14px;
    }

    .wrap{
      width:min(1120px, 100%);
      display:grid;
      grid-template-columns: minmax(0, 1fr) 340px;
      gap:14px;
      align-items:stretch;
    }
    @media (max-width: 980px){
      .wrap{ grid-template-columns: 1fr; }
    }
    .card{
      border-radius:16px;
      background: linear-gradient(180deg, rgba(255,255,255,.07), rgba(255,255,255,.03));
      border:1px solid var(--stroke);
      box-shadow: 0 14px 40px rgba(0,0,0,.45);
      overflow:hidden;
      min-width:0;
    }
    .stage{ position:relative; }
    .stage::before{
      content:"";
      position:absolute; inset:0;
      background: radial-gradient(800px 400px at 50% 100%, rgba(255,255,255,.08), transparent 60%);
      pointer-events:none;
    }
    canvas{ display:block; width:100%; height:auto; aspect-ratio:16/9; }

    .hud{
      position:absolute; inset:0;
      padding:12px;
      pointer-events:none;
      display:flex; flex-direction:column; justify-content:space-between;
    }
    .toprow{
      display:flex; justify-content:space-between; gap:12px; align-items:flex-start;
    }
    .pill{
      background: var(--panel);
      border:1px solid var(--stroke);
      border-radius:999px;
      padding:8px 12px;
      backdrop-filter: blur(10px);
      display:flex; gap:10px; align-items:center;
      font-weight:900;
    }
    .dot{ width:9px;height:9px;border-radius:99px;background:var(--accent); box-shadow:0 0 14px rgba(102,227,255,.75); }
    .pill small{ color:var(--muted); font-weight:800; }

    .msg{
      align-self:center;
      max-width:min(820px, 94%);
      text-align:center;
      background: var(--panel);
      border:1px solid var(--stroke);
      border-radius:14px;
      padding:10px 12px;
      backdrop-filter: blur(10px);
      font-weight:900;
      line-height:1.2;
    }
    .msg span{ color:var(--muted); font-weight:800; }

    .botrow{ display:flex; justify-content:space-between; align-items:flex-end; gap:12px; }
    .meter{
      width:min(420px, 62%);
      background: var(--panel);
      border:1px solid var(--stroke);
      border-radius:14px;
      padding:10px 12px;
      backdrop-filter: blur(10px);
    }
    .meter .label{ display:flex; justify-content:space-between; font-weight:950; margin-bottom:8px; }
    .bar{ height:10px; border-radius:999px; background: rgba(255,255,255,.10); overflow:hidden; position:relative; }
    .fill{ height:100%; width:0%; background: linear-gradient(90deg, rgba(102,227,255,.95), rgba(53,243,161,.95)); border-radius:999px; }
    .tick{ position:absolute; left:50%; top:-3px; bottom:-3px; width:2px; background: rgba(255,255,255,.22); }

    .kbd{
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono";
      font-weight:950;
      font-size:12px;
      background: rgba(255,255,255,.10);
      border:1px solid rgba(255,255,255,.14);
      padding:1px 6px;
      border-radius:8px;
      color: var(--text);
    }

    .side{ padding:14px; display:flex; flex-direction:column; gap:12px; }
    .side h2{ margin:0; font-size:16px; }
    .sub{ color:var(--muted); font-size:12.5px; line-height:1.35; }
    .panel{
      background: var(--panel);
      border:1px solid var(--stroke);
      border-radius:14px;
      padding:12px;
      backdrop-filter: blur(10px);
    }
    .stat{ font-weight:950; display:flex; flex-direction:column; gap:4px; }
    .stat small{ color:var(--muted); font-weight:850; }

    .kicks{ display:flex; gap:6px; flex-wrap:wrap; }
    .kdot{
      width:12px;height:12px;border-radius:99px;
      background: rgba(255,255,255,.14);
      border:1px solid rgba(255,255,255,.12);
    }
    .kdot.goal{ background: rgba(53,243,161,.85); border-color: rgba(53,243,161,.8); }
    .kdot.save{ background: rgba(255,92,122,.85); border-color: rgba(255,92,122,.8); }
    .kdot.miss{ background: rgba(255,255,255,.38); border-color: rgba(255,255,255,.30); }

    button{
      appearance:none;
      border:1px solid rgba(255,255,255,.14);
      background: linear-gradient(180deg, rgba(255,255,255,.10), rgba(255,255,255,.05));
      color:var(--text);
      padding:10px 12px;
      border-radius:12px;
      font-weight:950;
      cursor:pointer;
      transition: transform .06s ease, border-color .2s ease;
    }
    button:hover{ border-color: rgba(102,227,255,.45); }
    button:active{ transform: translateY(1px) scale(.995); }
    .btnRow{ display:flex; gap:10px; }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="card stage">
      <canvas id="c" width="1280" height="720"></canvas>

      <div class="hud">
        <div class="toprow">
          <div class="pill"><div class="dot"></div><div>
            <div>Penalty Shootout</div>
            <small id="kickLabel">Kick 1 / 10</small>
          </div></div>

          <div class="pill">
            <div class="stat">
              <div id="scoreLabel">Score: 0</div>
              <small id="keeperLabel">Keeper: Ready</small>
            </div>
          </div>
        </div>

        <div class="msg" id="msg">
          Click inside the goal to aim. <span>Hold <span class="kbd">SPACE</span> to power up, release to shoot.</span>
        </div>

        <div class="botrow">
          <div class="meter">
            <div class="label"><div>Power</div><div id="powerPct">0%</div></div>
            <div class="bar"><div class="tick"></div><div class="fill" id="powerFill"></div></div>
          </div>
          <div class="pill" style="gap:10px;">
            <small>Spin</small>
            <div id="spinLabel" style="font-weight:950;">0</div>
            <small>(A/D)</small>
          </div>
        </div>
      </div>
    </div>

    <div class="card side">
      <div>
        <h2>Controls</h2>
        <div class="sub">
          • Click to aim<br/>
          • Hold <span class="kbd">SPACE</span> → release to shoot<br/>
          • While charging: <span class="kbd">A</span>/<span class="kbd">D</span> adds curve<br/>
          • <span class="kbd">N</span> = new game
        </div>
      </div>

      <div class="panel">
        <div class="stat">
          <div id="resultLabel">Result: —</div>
          <small id="detailLabel">Pick a spot and shoot.</small>
        </div>
        <div style="height:10px"></div>
        <div class="stat"><div>Kick results</div><small>10 kicks total</small></div>
        <div style="height:8px"></div>
        <div class="kicks" id="kicks"></div>
      </div>

      <div class="panel sub">
        New realism:
        <ul style="margin:8px 0 0 18px; padding:0;">
          <li>Stadium crowd layer behind goal</li>
          <li>3D goalposts (rear posts + thick crossbar)</li>
          <li>Camera tilt so goal feels upright</li>
          <li>Saved shots bounce off the keeper</li>
        </ul>
      </div>

      <div class="btnRow">
        <button id="newBtn">New Game</button>
        <button id="resetBtn">Reset Kick</button>
      </div>
    </div>
  </div>

<script>
(() => {
  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d');

  // UI
  const msg = document.getElementById('msg');
  const kickLabel = document.getElementById('kickLabel');
  const scoreLabel = document.getElementById('scoreLabel');
  const keeperLabel = document.getElementById('keeperLabel');
  const powerFill = document.getElementById('powerFill');
  const powerPct = document.getElementById('powerPct');
  const spinLabel = document.getElementById('spinLabel');
  const resultLabel = document.getElementById('resultLabel');
  const detailLabel = document.getElementById('detailLabel');
  const kicksEl = document.getElementById('kicks');
  const newBtn = document.getElementById('newBtn');
  const resetBtn = document.getElementById('resetBtn');

  const W = canvas.width, H = canvas.height;

  // CAMERA TILT: draw everything on a slightly tilted camera by scaling Y + translating.
  // (Keeps UI untouched because UI is HTML overlay.)
  const camera = {
    tilt: 0.06,      // 0..0.12 feels good
    lift: 12         // pixels up
  };

  // Goal mouth quad (a bit more upright)
  const goal = {
    p0: {x: W*0.34, y: H*0.14},
    p1: {x: W*0.66, y: H*0.14},
    p2: {x: W*0.74, y: H*0.56},
    p3: {x: W*0.26, y: H*0.56},
  };

  // Goal depth: rear frame & net volume
  const depth = {
    insetU: 0.075,
    insetV: 0.07,
    drop: 22,
    squeezeX: 0.97
  };

  const ballStart = { x: W*0.50, y: H*0.86 };

  const state = {
    kick: 1,
    score: 0,
    results: [],
    aiming: true,
    charging: false,
    power: 0,
    spin: 0,
    aim: { x: W*0.50, y: H*0.34 },
    shot: null,
    keeper: null,
    tendencies: {L:0,C:0,R:0},

    // Ball bounce state after a save
    bounce: null,  // {t, dur, x0,y0, vx, vy, g, spin, scale0}
  };

  const keys = new Set();

  function clamp(v,a,b){ return Math.max(a, Math.min(b, v)); }
  function lerp(a,b,t){ return a + (b-a)*t; }
  function smoothstep(t){ return t*t*(3-2*t); }
  function rand(a,b){ return a + Math.random()*(b-a); }
  function setMessage(html){ msg.innerHTML = html; }

  // Geometry helpers
  function cross(ax,ay,bx,by){ return ax*by - ay*bx; }
  function pointInTri(p,a,b,c){
    const s1 = cross(b.x-a.x,b.y-a.y, p.x-a.x,p.y-a.y);
    const s2 = cross(c.x-b.x,c.y-b.y, p.x-b.x,p.y-b.y);
    const s3 = cross(a.x-c.x,a.y-c.y, p.x-c.x,p.y-c.y);
    const hasNeg = (s1<0)||(s2<0)||(s3<0);
    const hasPos = (s1>0)||(s2>0)||(s3>0);
    return !(hasNeg && hasPos);
  }
  function pointInQuad(pt, q){
    return pointInTri(pt, q.p0,q.p1,q.p2) || pointInTri(pt, q.p0,q.p2,q.p3);
  }

  function goalUVToScreen(u,v){
    const a=goal.p0,b=goal.p1,c=goal.p2,d=goal.p3;
    const topX = lerp(a.x,b.x,u), topY = lerp(a.y,b.y,u);
    const botX = lerp(d.x,c.x,u), botY = lerp(d.y,c.y,u);
    return { x: lerp(topX, botX, v), y: lerp(topY, botY, v) };
  }

  function backUVToScreen(u,v){
    const iu = clamp(u,0,1)*(1-2*depth.insetU) + depth.insetU;
    const iv = clamp(v,0,1)*(1-2*depth.insetV) + depth.insetV;
    const p = goalUVToScreen(iu, iv);
    const cx = W*0.5;
    return { x: cx + (p.x - cx)*depth.squeezeX, y: p.y + depth.drop };
  }

  function screenToGoalUV(x,y){
    let u = clamp((x - goal.p0.x)/(goal.p1.x-goal.p0.x), 0,1);
    let v = clamp((y - goal.p0.y)/(goal.p3.y-goal.p0.y), 0,1);
    for(let i=0;i<10;i++){
      const p = goalUVToScreen(u,v);
      const ex = x - p.x, ey = y - p.y;
      u = clamp(u + ex*0.0009, 0, 1);
      v = clamp(v + ey*0.0009, 0, 1);
    }
    return {u,v};
  }

  function initKickDots(){
    kicksEl.innerHTML = '';
    for(let i=0;i<10;i++){
      const d = document.createElement('div');
      d.className = 'kdot';
      kicksEl.appendChild(d);
    }
  }

  function resetKick(keepNumber=true){
    state.aiming = true;
    state.charging = false;
    state.power = 0;
    state.spin = 0;
    state.shot = null;
    state.keeper = null;
    state.bounce = null;

    powerFill.style.width = '0%';
    powerPct.textContent = '0%';
    spinLabel.textContent = '0';
    keeperLabel.textContent = 'Keeper: Ready';
    resultLabel.textContent = 'Result: —';
    detailLabel.textContent = 'Pick a spot and shoot.';

    if (!keepNumber){
      state.kick = 1;
      state.score = 0;
      state.results = [];
      state.tendencies = {L:0,C:0,R:0};
      initKickDots();
      scoreLabel.textContent = 'Score: 0';
    }

    kickLabel.textContent = `Kick ${state.kick} / 10`;
    setMessage(`Click inside the goal to aim. <span>Hold <span class="kbd">SPACE</span> to power up, release to shoot.</span>`);
  }

  function finishGame(){
    state.aiming = false;
    state.charging = false;
    keeperLabel.textContent = 'Keeper: Done';
    setMessage(`Final: <b>${state.score} / 10</b> <span>Press <span class="kbd">N</span> to start again.</span>`);
    detailLabel.textContent = 'Game over.';
  }

  function keeperAI(aimUV, power){
    const bucket = (aimUV.u < 0.34) ? 'L' : (aimUV.u > 0.66 ? 'R' : 'C');
    state.tendencies[bucket]++;

    const t = state.tendencies;
    const total = t.L+t.C+t.R+0.001;
    const biasU = (0.18*(t.L/total) + 0.50*(t.C/total) + 0.82*(t.R/total));

    const skill = 0.62;
    const aggression = 0.66;

    let predU = 0.50*(1-aggression) + (0.25+0.25*skill)*aimUV.u + (0.30+0.25*skill)*biasU;
    predU = clamp(predU + rand(-0.10,0.10)*(1-skill), 0.08, 0.92);

    let predV = clamp(lerp(0.64, aimUV.v, 0.42) + rand(-0.10,0.10)*(1-skill), 0.18, 0.92);

    const flight = lerp(0.95, 0.62, power);
    const reaction = clamp(0.22 + rand(-0.16, 0.16), 0.10, 0.45);
    const commitT = clamp(reaction + lerp(0.08, 0.02, skill), 0.10, 0.55);

    const dive = (predU < 0.40) ? -1 : (predU > 0.60 ? 1 : 0);
    const reach = lerp(0.11, 0.18, skill) * (dive===0 ? 0.86 : 1.0);

    return {predU,predV,flight,commitT,dive,reach};
  }

  function startShot(){
    const aimUV = screenToGoalUV(state.aim.x, state.aim.y);
    const p = clamp(state.power,0,1);
    const spin = clamp(state.spin,-1,1);

    const wild = smoothstep(clamp((p-0.78)/0.22, 0, 1));
    const spreadU = lerp(0.020, 0.075, wild);
    const spreadV = lerp(0.018, 0.060, wild);

    const curve = spin * lerp(0.00, 0.11, p);

    let tu = clamp(aimUV.u + rand(-spreadU, spreadU), 0.04, 0.96);
    let tv = clamp(aimUV.v + rand(-spreadV, spreadV), 0.06, 0.96);

    const cornerRisk = Math.max(Math.abs(tu-0.5)-0.20, 0)*1.35;
    const missChance = clamp(0.02 + 0.12*wild + 0.10*cornerRisk, 0.02, 0.28);

    const plan = keeperAI(aimUV, p);

    state.shot = {
      t:0,
      flight: plan.flight,
      start: {x:ballStart.x, y:ballStart.y},
      endUV: {u:tu, v:tv},
      spin, curve,
      willMiss: Math.random() < missChance,
      missType: 'none',
      outcome: null,
      committed: false,

      // used for bounce
      lastBall: {x: ballStart.x, y: ballStart.y}
    };

    state.keeper = { plan };

    state.aiming = false;
    keeperLabel.textContent = 'Keeper: Reading...';
    setMessage(`<b>Shot away!</b> <span>(power ${Math.round(p*100)}%)</span>`);
  }

  function resolveOutcome(){
    const s = state.shot;
    const plan = state.keeper.plan;
    if (!s || s.outcome) return;

    if (s.willMiss){
      const u=s.endUV.u, v=s.endUV.v;
      if (v < 0.10) s.missType = 'over the bar';
      else if (u < 0.10) s.missType = 'wide left';
      else if (u > 0.90) s.missType = 'wide right';
      else s.missType = 'hits the post';
      s.outcome = 'miss';
      return;
    }

    const impactU = clamp(s.endUV.u + s.curve, 0.02, 0.98);
    const impactV = s.endUV.v;

    const late = clamp((plan.commitT - (plan.flight*0.55)) / (plan.flight*0.45), 0, 1);
    const timeFactor = lerp(1.0, 0.75, late);

    const ku = clamp(plan.predU, 0.06, 0.94);
    const kv = clamp(plan.predV, 0.10, 0.92);

    const du = impactU - ku;
    const dv = impactV - kv;

    const cornerHard = clamp((Math.abs(impactU-0.5) + (0.60 - impactV)) * 0.65, 0, 0.55);
    const reach = plan.reach * timeFactor * (1.0 - 0.45*cornerHard);

    const dist = Math.hypot(du,dv);
    const roll = dist - reach + rand(-0.012, 0.020);
    s.outcome = (roll <= 0) ? 'save' : 'goal';
  }

  function startBounceFromSave(ballX, ballY){
    // Make it bounce out and down toward the grass.
    const dir = (ballX < W*0.5) ? -1 : 1;
    const speed = rand(520, 680);
    const angle = rand(-0.65, -0.25); // up a bit then down
    const vx = Math.cos(angle) * speed * dir;
    const vy = Math.sin(angle) * speed; // negative is up
    state.bounce = {
      t:0,
      dur: 0.55,
      x: ballX,
      y: ballY,
      vx,
      vy,
      g: 1600,           // gravity px/s^2
      damp: 0.55,        // energy loss on ground
      bounces: 0
    };
  }

  function commitKick(){
    const s = state.shot;
    if (!s || s.committed || !s.outcome) return;
    s.committed = true;

    // If save, do a bounce effect first (keep the shot state but clear later)
    if (s.outcome === 'save'){
      // Start bounce from last ball position (near keeper contact)
      startBounceFromSave(s.lastBall.x, s.lastBall.y);
    }

    state.results.push(s.outcome);
    const idx = state.results.length - 1;
    const dot = kicksEl.children[idx];
    if (dot) dot.classList.add(s.outcome);

    if (s.outcome === 'goal') state.score++;
    scoreLabel.textContent = `Score: ${state.score}`;

    if (s.outcome === 'goal'){
      resultLabel.textContent = 'Result: GOAL ✅';
      detailLabel.textContent = 'Clean finish.';
      keeperLabel.textContent = 'Keeper: Beaten';
      setMessage(`<b>GOAL!</b>`);
    } else if (s.outcome === 'save'){
      resultLabel.textContent = 'Result: SAVED ❌';
      detailLabel.textContent = 'Keeper parried it away.';
      keeperLabel.textContent = 'Keeper: Save';
      setMessage(`<b>SAVED!</b> <span>Parried out!</span>`);
    } else {
      resultLabel.textContent = 'Result: MISS ⚠️';
      detailLabel.textContent = `You ${s.missType}.`;
      keeperLabel.textContent = 'Keeper: Watches';
      setMessage(`<b>MISS!</b> <span>You ${s.missType}.</span>`);
    }

    // If not save, clear immediately. If save, let bounce animate, then clear.
    if (s.outcome !== 'save'){
      state.shot = null;
      state.keeper = null;

      if (state.kick >= 10){ finishGame(); return; }
      state.kick++;
      kickLabel.textContent = `Kick ${state.kick} / 10`;
      setTimeout(() => resetKick(true), 900);
    }
  }

  function endSaveAndAdvance(){
    state.shot = null;
    state.keeper = null;
    state.bounce = null;

    if (state.kick >= 10){ finishGame(); return; }
    state.kick++;
    kickLabel.textContent = `Kick ${state.kick} / 10`;
    setTimeout(() => resetKick(true), 850);
  }

  // Drawing primitives
  function roundRect(x,y,w,h,r){
    const rr = Math.min(r, w/2, h/2);
    ctx.beginPath();
    ctx.moveTo(x+rr,y);
    ctx.lineTo(x+w-rr,y);
    ctx.quadraticCurveTo(x+w,y,x+w,y+rr);
    ctx.lineTo(x+w,y+h-rr);
    ctx.quadraticCurveTo(x+w,y+h,x+w-rr,y+h);
    ctx.lineTo(x+rr,y+h);
    ctx.quadraticCurveTo(x,y+h,x,y+h-rr);
    ctx.lineTo(x,y+rr);
    ctx.quadraticCurveTo(x,y,x+rr,y);
    ctx.closePath();
  }

  function withCamera(fn){
    ctx.save();
    // Tilt: scale Y slightly and lift camera up
    ctx.translate(0, -camera.lift);
    ctx.transform(1, 0, 0, 1+camera.tilt, 0, 0);
    fn();
    ctx.restore();
  }

  // STADIUM / CROWD LAYER (behind goal)
  function drawStadiumBackdrop(){
    // Upper stands
    const top = H*0.02;
    const mid = H*0.36;

    // sky haze behind stands
    const haze = ctx.createLinearGradient(0, top, 0, mid);
    haze.addColorStop(0, 'rgba(255,255,255,.06)');
    haze.addColorStop(1, 'rgba(255,255,255,0)');
    ctx.fillStyle = haze;
    ctx.fillRect(0, top, W, mid-top);

    // stands structure
    const stands = ctx.createLinearGradient(0, top, 0, mid);
    stands.addColorStop(0, '#0a162b');
    stands.addColorStop(0.55, '#071225');
    stands.addColorStop(1, '#05101f');
    ctx.fillStyle = stands;
    ctx.fillRect(0, top, W, mid-top);

    // crowd dots (parallax)
    const bands = 6;
    for(let b=0;b<bands;b++){
      const y0 = lerp(top+18, mid-18, b/(bands-1));
      const density = lerp(380, 160, b/(bands-1));
      const size = lerp(2.2, 1.4, b/(bands-1));

      for(let i=0;i<density;i++){
        const x = Math.random()*W;
        const y = y0 + rand(-10, 10);
        // random shirts
        const r = Math.random();
        let col = 'rgba(255,255,255,.26)';
        if (r < 0.12) col = 'rgba(102,227,255,.32)';
        else if (r < 0.24) col = 'rgba(53,243,161,.30)';
        else if (r < 0.30) col = 'rgba(255,92,122,.28)';

        ctx.fillStyle = col;
        ctx.beginPath();
        ctx.arc(x, y, size, 0, Math.PI*2);
        ctx.fill();
      }
    }

    // stadium ribbon LED
    ctx.fillStyle = 'rgba(102,227,255,.10)';
    ctx.fillRect(0, mid-22, W, 14);

    // floodlight glow blobs
    function glow(x,y){
      const rg = ctx.createRadialGradient(x,y,0,x,y,240);
      rg.addColorStop(0,'rgba(255,255,255,.14)');
      rg.addColorStop(0.28,'rgba(255,255,255,.06)');
      rg.addColorStop(1,'rgba(255,255,255,0)');
      ctx.fillStyle = rg;
      ctx.beginPath(); ctx.arc(x,y,240,0,Math.PI*2); ctx.fill();
    }
    glow(W*0.18, H*0.10);
    glow(W*0.82, H*0.10);
  }

  function drawPitch(){
    const top = H*0.38;
    const g = ctx.createLinearGradient(0, top, 0, H);
    g.addColorStop(0, '#0c5b34');
    g.addColorStop(0.55, '#0a4f2e');
    g.addColorStop(1, '#083d24');
    ctx.fillStyle = g;
    ctx.fillRect(0, top, W, H-top);

    // stripes
    for(let i=0;i<14;i++){
      const x0 = -W*0.1 + (i/14)*W*1.2;
      ctx.fillStyle = i%2 ? 'rgba(255,255,255,.035)' : 'rgba(0,0,0,.05)';
      ctx.beginPath();
      ctx.moveTo(x0, top);
      ctx.lineTo(x0 + W*0.18, top);
      ctx.lineTo(x0 + W*0.40, H);
      ctx.lineTo(x0 + W*0.22, H);
      ctx.closePath();
      ctx.fill();
    }

    // goal line
    ctx.strokeStyle = 'rgba(255,255,255,.55)';
    ctx.lineWidth = 3;
    ctx.beginPath();
    ctx.moveTo(goal.p3.x-12, goal.p3.y+8);
    ctx.lineTo(goal.p2.x+12, goal.p2.y+8);
    ctx.stroke();

    // penalty spot
    ctx.fillStyle = 'rgba(255,255,255,.92)';
    ctx.beginPath(); ctx.arc(ballStart.x, ballStart.y+22, 4.5, 0, Math.PI*2); ctx.fill();
  }

  // 3D GOALPOSTS: front frame + rear frame + connecting depth bars
  function drawGoalPostsAndNet(){
    // Compute rear frame corners (depth)
    const f0 = goal.p0, f1 = goal.p1, f2 = goal.p2, f3 = goal.p3;
    const r0 = backUVToScreen(0,0);
    const r1 = backUVToScreen(1,0);
    const r2 = backUVToScreen(1,1);
    const r3 = backUVToScreen(0,1);

    // Side net shading for volume
    ctx.fillStyle = 'rgba(0,0,0,.18)';
    ctx.beginPath(); ctx.moveTo(f0.x,f0.y); ctx.lineTo(r0.x,r0.y); ctx.lineTo(r3.x,r3.y); ctx.lineTo(f3.x,f3.y); ctx.closePath(); ctx.fill();
    ctx.fillStyle = 'rgba(0,0,0,.16)';
    ctx.beginPath(); ctx.moveTo(f1.x,f1.y); ctx.lineTo(r1.x,r1.y); ctx.lineTo(r2.x,r2.y); ctx.lineTo(f2.x,f2.y); ctx.closePath(); ctx.fill();

    // rear frame shadow fill (back plane)
    ctx.fillStyle = 'rgba(0,0,0,.22)';
    ctx.beginPath(); ctx.moveTo(r0.x,r0.y); ctx.lineTo(r1.x,r1.y); ctx.lineTo(r2.x,r2.y); ctx.lineTo(r3.x,r3.y); ctx.closePath(); ctx.fill();

    // Net grid back
    ctx.strokeStyle = 'rgba(255,255,255,.20)';
    ctx.lineWidth = 1;
    for(let i=0;i<=16;i++){
      const u=i/16;
      const a=backUVToScreen(u,0), d=backUVToScreen(u,1);
      ctx.beginPath(); ctx.moveTo(a.x,a.y); ctx.lineTo(d.x,d.y); ctx.stroke();
    }
    for(let j=0;j<=9;j++){
      const v=j/9;
      const a=backUVToScreen(0,v), d=backUVToScreen(1,v);
      ctx.beginPath(); ctx.moveTo(a.x,a.y); ctx.lineTo(d.x,d.y); ctx.stroke();
    }

    // Net connectors to show depth strings
    ctx.strokeStyle = 'rgba(255,255,255,.12)';
    ctx.beginPath(); ctx.moveTo(f0.x,f0.y); ctx.lineTo(r0.x,r0.y);
    ctx.moveTo(f1.x,f1.y); ctx.lineTo(r1.x,r1.y);
    ctx.moveTo(f2.x,f2.y); ctx.lineTo(r2.x,r2.y);
    ctx.moveTo(f3.x,f3.y); ctx.lineTo(r3.x,r3.y);
    ctx.stroke();

    // GOALPOST THICKNESS
    // Draw rear frame first (slightly darker)
    ctx.lineWidth = 10;
    ctx.strokeStyle = 'rgba(255,255,255,.60)';
    ctx.beginPath();
    ctx.moveTo(r0.x,r0.y); ctx.lineTo(r1.x,r1.y); ctx.lineTo(r2.x,r2.y); ctx.lineTo(r3.x,r3.y); ctx.closePath();
    ctx.stroke();

    // Depth bars (connect front and rear frame) - makes it look like a box
    ctx.lineWidth = 12;
    const depthStroke = ctx.createLinearGradient(0,0,0,H);
    depthStroke.addColorStop(0,'rgba(255,255,255,.75)');
    depthStroke.addColorStop(1,'rgba(255,255,255,.45)');
    ctx.strokeStyle = depthStroke;
    ctx.beginPath();
    ctx.moveTo(f0.x,f0.y); ctx.lineTo(r0.x,r0.y);
    ctx.moveTo(f1.x,f1.y); ctx.lineTo(r1.x,r1.y);
    ctx.moveTo(f2.x,f2.y); ctx.lineTo(r2.x,r2.y);
    ctx.moveTo(f3.x,f3.y); ctx.lineTo(r3.x,r3.y);
    ctx.stroke();

    // Front frame thick crossbar + posts (bright)
    ctx.lineWidth = 14;
    ctx.strokeStyle = 'rgba(255,255,255,.94)';
    ctx.shadowColor = 'rgba(0,0,0,.40)';
    ctx.shadowBlur = 10;
    ctx.shadowOffsetY = 6;

    ctx.beginPath();
    ctx.moveTo(f0.x,f0.y); ctx.lineTo(f1.x,f1.y); // crossbar
    ctx.lineTo(f2.x,f2.y);
    ctx.lineTo(f3.x,f3.y);
    ctx.closePath();
    ctx.stroke();

    ctx.shadowBlur = 0;
    ctx.shadowOffsetY = 0;

    // Subtle highlight on crossbar thickness
    ctx.strokeStyle = 'rgba(255,255,255,.35)';
    ctx.lineWidth = 4;
    ctx.beginPath();
    ctx.moveTo(f0.x, f0.y-2);
    ctx.lineTo(f1.x, f1.y-2);
    ctx.stroke();
  }

  function drawKeeper(time){
    // Idle in center
    let u=0.5, v=0.68, rot=0, stretch=0;

    if (state.shot && state.keeper){
      const plan = state.keeper.plan;
      const commit = (time < plan.commitT) ? 0 : smoothstep(clamp((time-plan.commitT)/(plan.flight-plan.commitT+1e-6), 0, 1));
      u = lerp(0.5, plan.predU, commit);
      v = lerp(0.68, plan.predV, commit*0.75);
      rot = plan.dive * commit * 0.55;
      stretch = commit;
    } else {
      const s = Math.sin(performance.now()/520)*0.012;
      u = 0.5 + s;
    }

    const p = goalUVToScreen(u,v);

    ctx.save();
    ctx.translate(p.x,p.y);

    const depthScale = lerp(0.86, 1.20, clamp((p.y - goal.p0.y)/(goal.p3.y - goal.p0.y), 0, 1));
    ctx.scale(depthScale, depthScale);
    ctx.rotate(rot);

    // shadow
    ctx.globalAlpha = 0.32;
    ctx.fillStyle = 'rgba(0,0,0,.38)';
    ctx.beginPath();
    ctx.ellipse(0, 70, 42 + 22*stretch, 12, 0, 0, Math.PI*2);
    ctx.fill();
    ctx.globalAlpha = 1;

    const jersey = ctx.createLinearGradient(-40,-40,40,60);
    jersey.addColorStop(0,'#1ed16b');
    jersey.addColorStop(0.6,'#10a95a');
    jersey.addColorStop(1,'#0c7c46');

    const shorts = ctx.createLinearGradient(-30,10,30,90);
    shorts.addColorStop(0,'#2b3446');
    shorts.addColorStop(1,'#151c2a');

    // torso
    ctx.fillStyle = jersey;
    roundRect(-34, -28, 68, 64, 16);
    ctx.fill();

    // arms + gloves
    const armW=18, armL=56;
    const armTilt = 0.45 + 0.95*stretch;

    ctx.save();
    ctx.rotate(-armTilt);
    ctx.fillStyle = jersey; roundRect(-armW-6, -18, armW, armL, 10); ctx.fill();
    ctx.fillStyle = '#f1f5ff'; roundRect(-armW-10, 28, armW+8, 18, 9); ctx.fill();
    ctx.restore();

    ctx.save();
    ctx.rotate(armTilt);
    ctx.fillStyle = jersey; roundRect(6, -18, armW, armL, 10); ctx.fill();
    ctx.fillStyle = '#f1f5ff'; roundRect(4, 28, armW+8, 18, 9); ctx.fill();
    ctx.restore();

    // shorts
    ctx.fillStyle = shorts;
    roundRect(-30, 30, 60, 36, 12);
    ctx.fill();

    // legs
    const sock = ctx.createLinearGradient(-10,50,10,110);
    sock.addColorStop(0,'#e9f0ff');
    sock.addColorStop(1,'#cfd9f2');
    ctx.fillStyle = sock;
    roundRect(-22, 58, 18, 44, 9); ctx.fill();
    roundRect(  4, 58, 18, 44, 9); ctx.fill();

    // boots
    ctx.fillStyle = '#0b0f18';
    roundRect(-26, 96, 26, 14, 7); ctx.fill();
    roundRect(  0, 96, 26, 14, 7); ctx.fill();

    // head
    const skin = ctx.createRadialGradient(0,-50,6,0,-44,26);
    skin.addColorStop(0,'#ffddb9');
    skin.addColorStop(1,'#e6b48b');
    ctx.fillStyle = skin;
    ctx.beginPath(); ctx.arc(0, -48, 20, 0, Math.PI*2); ctx.fill();

    // hair
    ctx.fillStyle = 'rgba(40,25,18,.9)';
    ctx.beginPath(); ctx.arc(0, -56, 18, Math.PI, Math.PI*2); ctx.fill();

    // face shading
    ctx.fillStyle = 'rgba(0,0,0,.12)';
    ctx.beginPath(); ctx.arc(7, -44, 18, -0.6, 0.9); ctx.fill();

    ctx.restore();
  }

  function drawBall(pos, scale, blur=0){
    ctx.save();
    ctx.translate(pos.x,pos.y);
    ctx.scale(scale, scale);

    if (blur>0){
      ctx.globalAlpha = 0.16;
      ctx.fillStyle = 'rgba(255,255,255,.7)';
      ctx.beginPath();
      ctx.ellipse(-22*blur, 8*blur, 18+10*blur, 10+6*blur, 0, 0, Math.PI*2);
      ctx.fill();
      ctx.globalAlpha = 1;
    }

    const g = ctx.createRadialGradient(-10,-12,6,0,0,34);
    g.addColorStop(0,'#ffffff');
    g.addColorStop(0.55,'#f1f3f7');
    g.addColorStop(1,'#cfd7e6');

    ctx.fillStyle = g;
    ctx.beginPath(); ctx.arc(0,0,28,0,Math.PI*2); ctx.fill();

    ctx.strokeStyle = 'rgba(20,30,50,.38)';
    ctx.lineWidth = 2;
    for(let i=0;i<6;i++){
      const a=(i/6)*Math.PI*2;
      ctx.beginPath(); ctx.arc(0,0,18,a,a+Math.PI/2); ctx.stroke();
    }
    ctx.beginPath(); ctx.arc(0,0,9,0,Math.PI*2); ctx.stroke();

    ctx.fillStyle = 'rgba(255,255,255,.75)';
    ctx.beginPath(); ctx.ellipse(-10,-12,9,6,-0.4,0,Math.PI*2); ctx.fill();

    ctx.restore();
  }

  function drawReticle(){
    if (!state.aiming) return;
    const inside = pointInQuad({x:state.aim.x,y:state.aim.y}, goal);
    const x=state.aim.x, y=state.aim.y;

    ctx.save();
    ctx.globalAlpha = inside ? 0.95 : 0.40;

    const rg = ctx.createRadialGradient(x,y,0,x,y,44);
    rg.addColorStop(0,'rgba(102,227,255,.20)');
    rg.addColorStop(0.5,'rgba(102,227,255,.08)');
    rg.addColorStop(1,'rgba(102,227,255,0)');
    ctx.fillStyle = rg;
    ctx.beginPath(); ctx.arc(x,y,44,0,Math.PI*2); ctx.fill();

    ctx.strokeStyle = inside ? 'rgba(102,227,255,.95)' : 'rgba(255,255,255,.45)';
    ctx.lineWidth = 2;
    ctx.beginPath(); ctx.arc(x,y,16,0,Math.PI*2); ctx.stroke();
    ctx.beginPath();
    ctx.moveTo(x-26,y); ctx.lineTo(x-10,y);
    ctx.moveTo(x+10,y); ctx.lineTo(x+26,y);
    ctx.moveTo(x,y-26); ctx.lineTo(x,y-10);
    ctx.moveTo(x,y+10); ctx.lineTo(x,y+26);
    ctx.stroke();

    ctx.restore();
  }

  // Input mapping
  function eventToCanvas(e){
    const r = canvas.getBoundingClientRect();
    return {
      x: (e.clientX - r.left) * (W / r.width),
      y: (e.clientY - r.top)  * (H / r.height)
    };
  }

  canvas.addEventListener('mousemove', (e) => {
    const p = eventToCanvas(e);
    if (state.aiming){ state.aim = p; }
  });

  canvas.addEventListener('click', (e) => {
    if (!state.aiming) return;
    const p = eventToCanvas(e);
    if (pointInQuad(p, goal)){
      state.aim = p;
      setMessage(`Aim set. <span>Hold <span class="kbd">SPACE</span> to power up, release to shoot.</span>`);
    } else {
      setMessage(`Click <b>inside the goal</b> to aim. <span>Then hold <span class="kbd">SPACE</span>.</span>`);
    }
  });

  window.addEventListener('keydown', (e) => {
    if (e.code === 'Space') e.preventDefault();
    keys.add(e.code);

    if (e.code === 'KeyN'){ resetKick(false); return; }
    if (!state.aiming) return;

    if (e.code === 'Space' && !state.charging){
      if (!pointInQuad({x:state.aim.x,y:state.aim.y}, goal)){
        setMessage(`Aim first: click <b>inside the goal</b>.`);
        return;
      }
      state.charging = true;
      setMessage(`Charging… <span>Use <span class="kbd">A</span>/<span class="kbd">D</span> for curve.</span>`);
    }
  });

  window.addEventListener('keyup', (e) => {
    keys.delete(e.code);
    if (e.code === 'Space'){
      if (state.charging && state.aiming){
        state.charging = false;
        startShot();
      }
    }
  });

  newBtn.addEventListener('click', () => resetKick(false));
  resetBtn.addEventListener('click', () => { if (!state.shot && !state.bounce) resetKick(true); });

  // Animate bounce ball after save
  function updateBounce(dt){
    const b = state.bounce;
    if (!b) return null;

    b.t += dt;

    // physics step
    b.vy += b.g * dt;
    b.x += b.vx * dt;
    b.y += b.vy * dt;

    // ground collision near pitch top line (rough)
    const groundY = H*0.60; // visually near goal mouth base
    if (b.y > groundY && b.vy > 0){
      b.y = groundY;
      b.vy = -b.vy * b.damp;
      b.vx *= 0.80;
      b.bounces++;
      // stop after a couple bounces
      if (b.bounces >= 2 || Math.abs(b.vy) < 180){
        // finish bounce
        state.bounce = null;
        endSaveAndAdvance();
        return null;
      }
    }

    // stop if too long
    if (b.t > 1.2){
      state.bounce = null;
      endSaveAndAdvance();
      return null;
    }

    return {x:b.x, y:b.y};
  }

  // Animation loop
  let last = performance.now();
  function frame(now){
    const dt = Math.min(0.033, (now-last)/1000);
    last = now;

    if (state.aiming && state.charging){
      state.power = clamp(state.power + dt*0.85, 0, 1);
      if (keys.has('KeyA')) state.spin = clamp(state.spin - dt*1.6, -1, 1);
      if (keys.has('KeyD')) state.spin = clamp(state.spin + dt*1.6, -1, 1);

      powerFill.style.width = `${Math.round(state.power*100)}%`;
      powerPct.textContent = `${Math.round(state.power*100)}%`;
      spinLabel.textContent = `${Math.round(state.spin*100)}`;
    } else if (state.aiming){
      state.spin = lerp(state.spin, 0, dt*2.2);
      spinLabel.textContent = `${Math.round(state.spin*100)}`;
    }

    // Draw world with camera tilt
    withCamera(() => {
      // BACKGROUND stadium behind goal
      drawStadiumBackdrop();

      // pitch
      drawPitch();

      // goal volume + net + 3D posts
      drawGoalPostsAndNet();

      // keeper always visible
      if (state.shot) drawKeeper(state.shot.t);
      else drawKeeper(0);

      // ball: either normal shot, bounce, or idle
      if (state.bounce){
        const p = updateBounce(dt);
        if (p) drawBall(p, 0.26, 0.35);
      } else if (!state.shot){
        drawBall(ballStart, 0.52, 0);
      } else {
        const s = state.shot;
        s.t += dt;

        const t = clamp(s.t / s.flight, 0, 1);
        const te = smoothstep(t);

        const curveNow = s.curve * (t*t);
        const end = goalUVToScreen(clamp(s.endUV.u + curveNow, 0.02, 0.98), s.endUV.v);

        const x = lerp(s.start.x, end.x, te);
        const y = lerp(s.start.y, end.y, te);

        // store last ball position for bounce start
        s.lastBall.x = x;
        s.lastBall.y = y;

        const scale = lerp(0.52, 0.20, te);
        const blur = te * lerp(0.2, 1.0, clamp(state.power,0,1));
        drawBall({x,y}, scale, blur);

        if (s.t < state.keeper.plan.commitT) keeperLabel.textContent = 'Keeper: Reading...';
        else keeperLabel.textContent = 'Keeper: Diving!';

        if (t >= 0.98 && !s.outcome) resolveOutcome();
        if (t >= 1.00 && s.outcome && !s.committed) commitKick();
      }
    });

    // reticle not camera-tilted (so it tracks cursor precisely)
    drawReticle();

    requestAnimationFrame(frame);
  }

  initKickDots();
  resetKick(false);
  requestAnimationFrame(frame);
})();
</script>
</body>
</html>
